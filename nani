diff --git a/include/EKF-Module/ball_ekf_module.hpp b/include/EKF-Module/ball_ekf_module.hpp
index 922fa04..64ea35c 100644
--- a/include/EKF-Module/ball_ekf_module.hpp
+++ b/include/EKF-Module/ball_ekf_module.hpp
@@ -28,12 +28,9 @@ class BallEKF_Module : public Module {
         virtual void init_subscribers();
 
         void publish_ball_data(BallData data);
-        arma::vec get_ball_loc();
-        arma::vec get_ball_vel();
 
         ITPS::NonBlockingPublisher<BallEKF_Module::BallData> ball_data_pub;
-        ITPS::NonBlockingSubscriber<arma::vec> ball_loc_sub; //("GVision Server", "BallPos(BodyFrame)"); 
-        ITPS::NonBlockingSubscriber<arma::vec> ball_vel_sub; //("GVision Server", "BallVel(BodyFrame)");
+        // add ssl vision subscriber later
         
 };
 
diff --git a/include/EKF-Module/virtual_ball_ekf.hpp b/include/EKF-Module/virtual_ball_ekf.hpp
index c568141..9f22b09 100644
--- a/include/EKF-Module/virtual_ball_ekf.hpp
+++ b/include/EKF-Module/virtual_ball_ekf.hpp
@@ -13,9 +13,15 @@ class VirtualBallEKF : public BallEKF_Module {
         void task(ThreadPool& thread_pool);
 
     private:
-
+        boost::shared_ptr<boost::asio::ip::udp::socket> socket; 
+        boost::shared_ptr<boost::asio::ip::udp::endpoint> grsim_endpoint;
+        boost::shared_ptr<boost::asio::deadline_timer> timer;
+        boost::asio::io_service io_service;
+        
+        arma::vec prev_disp = {0, 0};
         BallEKF::BallData ball_data;
         B_Log logger;
-
+        void loop();
+        void velocity_calc_timer_task();
 
 };
\ No newline at end of file
diff --git a/include/EKF-Module/virtual_motion_ekf.hpp b/include/EKF-Module/virtual_motion_ekf.hpp
index e05270e..a598a15 100644
--- a/include/EKF-Module/virtual_motion_ekf.hpp
+++ b/include/EKF-Module/virtual_motion_ekf.hpp
@@ -20,6 +20,8 @@ class VirtualMotionEKF : public MotionEKF_Module {
 
         arma::vec prev_disp = {0, 0};
         MotionEKF::MotionData motion_data;
-
+        void getPositionData();
+        void loop();
+        void velocity_calc_timer_task();
 
 };
\ No newline at end of file
diff --git a/include/PubSubSystem/publisher_subscriber.hpp b/include/PubSubSystem/publisher_subscriber.hpp
index e3108d3..f333223 100644
--- a/include/PubSubSystem/publisher_subscriber.hpp
+++ b/include/PubSubSystem/publisher_subscriber.hpp
@@ -28,7 +28,6 @@
 
 
 
-#define AVOID_STARVATION_DELAY 100 // unit: microseconds
 
 
 
@@ -179,7 +178,6 @@ namespace ITPS {
                                                // pull latest msg before publisher ever published anything
             }
             void publish(Msg message) {
-                boost::this_thread::sleep_for(boost::chrono::microseconds(AVOID_STARVATION_DELAY));
                 this->channel->set_msg(message);
             }    
 
@@ -284,9 +282,7 @@ namespace ITPS {
             // Non-blocking Mode getter method
             Msg latest_msg() {
                 // non-blocking
-                Msg rtn = this->channel->get_msg();
-                boost::this_thread::sleep_for(boost::chrono::microseconds(AVOID_STARVATION_DELAY));
-                return rtn;
+                return this->channel->get_msg();
             }   
 
             // method reserved for special use case only
diff --git a/include/RemoteServers/RemoteCMDServer/cmd_server_module.hpp b/include/RemoteServers/RemoteCMDServer/cmd_server_module.hpp
index c417afa..6a12a75 100644
--- a/include/RemoteServers/RemoteCMDServer/cmd_server_module.hpp
+++ b/include/RemoteServers/RemoteCMDServer/cmd_server_module.hpp
@@ -5,7 +5,8 @@
 class CMDServerModule : public Module {
     public:
         virtual void task() {}
-        virtual void task(ThreadPool& thread_pool);
+
+    [[noreturn]] virtual void task(ThreadPool& thread_pool);
 
         virtual ~CMDServerModule() {}
 
diff --git a/source/BallCaptureModule/ball_capture_module.cpp b/source/BallCaptureModule/ball_capture_module.cpp
index 1fae6ff..96889e9 100644
--- a/source/BallCaptureModule/ball_capture_module.cpp
+++ b/source/BallCaptureModule/ball_capture_module.cpp
@@ -89,7 +89,7 @@ void BallCaptureModule::init_subscribers() {
         }
 
         //if(enable_sub.latest_msg()){
-        if(true){
+        if(false){
             MotionEKF_Module::MotionData latest_motion_data = motion_data_sub.latest_msg(); // Robot data is in robot frame
             BallEKF_Module::BallData latest_ball_data = ball_data_sub.latest_msg(); // Ball data is in world frame
 
diff --git a/source/Config/config.cpp b/source/Config/config.cpp
index 0194857..666c271 100644
--- a/source/Config/config.cpp
+++ b/source/Config/config.cpp
@@ -49,11 +49,12 @@ float PID_TVRV_CORR = 1.0;
 float PID_MAX_ROT_PERC = 30.00;
 
 
-/* These values will be different for different robots, hence be reset in another file */
-int CONN_SERVER_PORT = 6000; // juts an arbitary default val
-int CMD_SERVER_PORT = 6001; // juts an arbitary default val
-int EKF_SERVER_PORT = 6002; // juts an arbitary default val
-int GVISION_SERVER_PORT = 6003; // juts an arbitary default val
+
+int CONN_SERVER_PORT = 6000;
+int CMD_SERVER_PORT = 6001;
+int EKF_SERVER_PORT = 6002;
+int GVISION_SERVER_PORT = 6003;
+
 
 
 
diff --git a/source/EKF-Module/ball_ekf_module.cpp b/source/EKF-Module/ball_ekf_module.cpp
index 43c8491..3a35c12 100644
--- a/source/EKF-Module/ball_ekf_module.cpp
+++ b/source/EKF-Module/ball_ekf_module.cpp
@@ -14,9 +14,7 @@ static BallEKF::BallData dft_bd() {
 } 
 
 
-BallEKF_Module::BallEKF_Module() : ball_data_pub("BallEKF", "BallData", dft_bd()),
-                                   ball_loc_sub("GVision Server", "BallPos(BodyFrame)"),
-                                   ball_vel_sub("GVision Server", "BallVel(BodyFrame)")
+BallEKF_Module::BallEKF_Module() : ball_data_pub("BallEKF", "BallData", dft_bd())
 {}
 
 BallEKF_Module::~BallEKF_Module() {} 
@@ -24,8 +22,7 @@ BallEKF_Module::~BallEKF_Module() {}
 
 void BallEKF_Module::init_subscribers() {
     try {
-        ball_loc_sub.subscribe(DEFAULT_SUBSCRIBER_TIMEOUT);
-        ball_vel_sub.subscribe(DEFAULT_SUBSCRIBER_TIMEOUT);
+        // add ssl vision subscriber later
     }
     catch(std::exception& e) {
         B_Log logger;
@@ -41,11 +38,3 @@ void BallEKF_Module::publish_ball_data(BallData data) {
     ball_data_pub.publish(data);
 }
 
-arma::vec BallEKF_Module::get_ball_loc() {
-    return ball_loc_sub.latest_msg();
-}
-
-arma::vec BallEKF_Module::get_ball_vel() {
-    return ball_vel_sub.latest_msg();
-}
-
diff --git a/source/EKF-Module/virtual_ball_ekf.cpp b/source/EKF-Module/virtual_ball_ekf.cpp
index 904b8c4..c1ce38f 100644
--- a/source/EKF-Module/virtual_ball_ekf.cpp
+++ b/source/EKF-Module/virtual_ball_ekf.cpp
@@ -7,6 +7,9 @@
 #include "ProtoGenerated/messages_robocup_ssl_geometry.pb.h"
 #include "Utility/common.hpp"
 
+const bool is_blue_team_side = true;
+const int vel_sample_period_ms = 50; // 50 ms 
+const double vel_max_thresh = 10000.00; // 10000 mm/s == 10 m/s (threshold for the norm of vel vector)
 
 using namespace boost;
 using namespace boost::asio;
@@ -24,13 +27,71 @@ void VirtualBallEKF::task(ThreadPool& thread_pool) {
     init_subscribers();
     logger(Info) << "\033[0;32m Initialized \033[0m";
 
+    grsim_endpoint = boost::shared_ptr<udp::endpoint>(
+        new udp::endpoint(address::from_string(GRSIM_VISION_IP), GRSIM_VISION_PORT)
+    );
+    this->socket = boost::shared_ptr<udp::socket>(new udp::socket(io_service));
+    this->timer = boost::shared_ptr<deadline_timer>(new deadline_timer(io_service));
 
-    BallData ball_data;
+    socket->open(grsim_endpoint->protocol());
+    socket->set_option(udp::socket::reuse_address(true));
+    socket->bind(*grsim_endpoint);
+    socket->set_option(ip::multicast::join_group(grsim_endpoint->address()));
 
-    while(true) {
-        ball_data.disp = get_ball_loc();
-        ball_data.vel = get_ball_vel();
+    // default async task that keeps looping in the background
+    io_service.post(boost::bind(&VirtualBallEKF::loop, this)); // .post means postpone, meaning that this task has lower priority in the task queue
+    
+    // timed periodic task
+    timer->expires_from_now(posix_time::millisec(vel_sample_period_ms));
+    timer->async_wait(boost::bind(&VirtualBallEKF::velocity_calc_timer_task, this)); 
 
-        logger.log(Info, "<" + repr(ball_data.disp(0)) + ", " + repr(ball_data.disp(1)) + ">");
+    io_service.run();
+}
+
+void VirtualBallEKF::velocity_calc_timer_task() {
+    arma::vec vel = ((ball_data.disp - prev_disp) / vel_sample_period_ms) * 1000.00; // unit: mm/s
+    if(arma::norm(vel) < vel_max_thresh) {
+        ball_data.vel = vel;
     }
+    prev_disp = ball_data.disp;
+
+    // recursive call at the next time point
+    timer->expires_from_now(posix_time::millisec(vel_sample_period_ms));
+    timer->async_wait(boost::bind(&VirtualBallEKF::velocity_calc_timer_task, this));
 }
+
+
+void VirtualBallEKF::loop() {
+    boost::array<char, UDP_RBUF_SIZE> receive_buffer;
+    
+    size_t num_bytes_received;
+    std::string packet_string;
+    SSL_WrapperPacket packet;
+    google::protobuf::RepeatedPtrField<SSL_DetectionBall> balls;
+
+    num_bytes_received = socket->receive_from(asio::buffer(receive_buffer), *grsim_endpoint);
+    packet_string = std::string(receive_buffer.begin(), 
+                                receive_buffer.begin() + num_bytes_received);
+
+    packet.ParseFromString(packet_string);
+
+    balls = packet.detection().balls();
+    
+
+    if(balls.size() == 1) {
+        auto ball = balls[0];
+
+        // grsim's x & y are reversed due to diff view perspective
+        if(is_blue_team_side) {
+            ball_data.disp = {-ball.y(), ball.x()};
+        }
+        else {
+            ball_data.disp = {ball.y(), -ball.x()};
+        }
+        publish_ball_data(ball_data);
+    
+    }
+
+    // Recursive call to enqueue loop func as an dft async task
+    io_service.post(boost::bind(&VirtualBallEKF::loop, this));
+}
\ No newline at end of file
diff --git a/source/EKF-Module/virtual_motion_ekf.cpp b/source/EKF-Module/virtual_motion_ekf.cpp
index 958a44e..eb378ee 100644
--- a/source/EKF-Module/virtual_motion_ekf.cpp
+++ b/source/EKF-Module/virtual_motion_ekf.cpp
@@ -32,7 +32,8 @@ VirtualMotionEKF::~VirtualMotionEKF() = default;
     MotionEKF::MotionData m_data;
 
     while(true) {
-        // firm data is in body(not global) frame!
+        // Motion data is return in non-global frame!
+        // The actual
         vf_data = get_firmware_data();
 
         if(false){
@@ -55,3 +56,70 @@ VirtualMotionEKF::~VirtualMotionEKF() = default;
         
     }
 }
+
+void VirtualMotionEKF::getPositionData() {
+    grsim_endpoint = boost::shared_ptr<udp::endpoint>(
+            new udp::endpoint(address::from_string(GRSIM_VISION_IP), GRSIM_VISION_PORT)
+    );
+    this->socket = boost::shared_ptr<udp::socket>(new udp::socket(io_service));
+    this->timer = boost::shared_ptr<deadline_timer>(new deadline_timer(io_service));
+
+    socket->open(grsim_endpoint->protocol());
+    socket->set_option(udp::socket::reuse_address(true));
+    socket->bind(*grsim_endpoint);
+    socket->set_option(ip::multicast::join_group(grsim_endpoint->address()));
+
+    // default async task that keeps looping in the background
+    io_service.post(boost::bind(&VirtualMotionEKF::loop, this)); // .post means postpone, meaning that this task has lower priority in the task queue
+
+    // timed periodic task
+    timer->expires_from_now(posix_time::millisec(vel_sample_period_ms));
+    timer->async_wait(boost::bind(&VirtualMotionEKF::velocity_calc_timer_task, this));
+}
+
+void VirtualMotionEKF::loop() {
+    boost::array<char, UDP_RBUF_SIZE> receive_buffer;
+
+    size_t num_bytes_received;
+    std::string packet_string;
+    SSL_WrapperPacket packet;
+    google::protobuf::RepeatedPtrField<SSL_DetectionBall> balls;
+
+    num_bytes_received = socket->receive_from(asio::buffer(receive_buffer), *grsim_endpoint);
+    packet_string = std::string(receive_buffer.begin(),
+                                receive_buffer.begin() + num_bytes_received);
+
+    packet.ParseFromString(packet_string);
+
+    balls = packet.detection().balls();
+
+
+    if(balls.size() == 1) {
+        auto ball = balls[0];
+
+        // grsim's x & y are reversed due to diff view perspective
+        if(is_blue_team_side) {
+            motion_data.trans_disp = {-ball.y(), ball.x()};
+        }
+        else {
+            motion_data.trans_disp = {ball.y(), -ball.x()};
+        }
+
+    }
+
+    // Recursive call to enqueue loop func as an dft async task
+    io_service.post(boost::bind(&VirtualMotionEKF::loop, this));
+
+}
+
+void VirtualMotionEKF::velocity_calc_timer_task() {
+    arma::vec vel = ((motion_data.trans_disp - prev_disp) / vel_sample_period_ms) * 1000.00; // unit: mm/s
+    if(arma::norm(vel) < vel_max_thresh) {
+        motion_data.trans_vel = vel;
+    }
+    prev_disp = motion_data.trans_disp;
+
+    // recursive call at the next time point
+    timer->expires_from_now(posix_time::millisec(vel_sample_period_ms));
+    timer->async_wait(boost::bind(&VirtualMotionEKF::velocity_calc_timer_task, this));
+}
\ No newline at end of file
diff --git a/source/Main/settings.cpp b/source/Main/settings.cpp
index 0872491..5166341 100644
--- a/source/Main/settings.cpp
+++ b/source/Main/settings.cpp
@@ -49,6 +49,7 @@ bool process_args(int argc, char *argv[]) {
             CMD_SERVER_PORT = CONN_SERVER_PORT + 1;
             EKF_SERVER_PORT = CONN_SERVER_PORT + 2;
             GVISION_SERVER_PORT = CONN_SERVER_PORT + 3;
+
             
             // <vfirm ip>
             VFIRM_IP_ADDR = std::string(argv[argc - 2]);
@@ -62,6 +63,7 @@ bool process_args(int argc, char *argv[]) {
             CMD_SERVER_PORT = CONN_SERVER_PORT + 1;
             EKF_SERVER_PORT = CONN_SERVER_PORT + 2;
             GVISION_SERVER_PORT = CONN_SERVER_PORT + 3;
+
             
             // <vfirm port>
             VFIRM_IP_PORT = std::stoi( std::string(argv[argc - 1]), nullptr, 10 );
diff --git a/source/Main/tritonbot.cpp b/source/Main/tritonbot.cpp
index bbbefbe..70089c3 100644
--- a/source/Main/tritonbot.cpp
+++ b/source/Main/tritonbot.cpp
@@ -32,8 +32,8 @@ int main(int argc, char *argv[]) {
     // Logger Initialization
     B_Log::static_init();
     B_Log::set_shorter_format();
-    //B_Log::sink->set_filter(severity >= Debug && tag_attr == "PseudoBallEKF Module");
-    B_Log::sink->set_filter(severity >= Info);    
+    B_Log::sink->set_filter(severity >= Debug && tag_attr == "Global Vision Server Module");
+//    B_Log::sink->set_filter(severity >= Info);
     B_Log logger;
     
     // Process Json configurations
diff --git a/source/MotionModule/motion_module.cpp b/source/MotionModule/motion_module.cpp
index 23242c4..22e5297 100644
--- a/source/MotionModule/motion_module.cpp
+++ b/source/MotionModule/motion_module.cpp
@@ -102,12 +102,6 @@ void MotionModule::move(arma::vec setpoint_3d, CTRL_Mode mode, ReferenceFrame se
             arma::vec bot_origin = robot_origin_w_sub.latest_msg();
             double bot_orien = sensor_sub.latest_msg().rotat_disp;
 
-            /* The math trick here is we define body frame to be (bot_origin_x, bot_origin_y, bot_orien)
-             * in which bot_origin_x/y are static, while bot_orien changes along with the moving robot.
-             * This is meant to simplify things to avoid having a body frame that moves. So we in fact
-             * have a stationary body frame that essentially only have the rotation transformation being meaningful
-             */
-
             /* a not-so-obvious simplification was done by 
                 * using bot_origin as the bot curr location */
             arma::mat A = wtb_homo_transform(bot_origin, bot_orien); // world to body homogeneous transformation
diff --git a/source/RemoteServers/GlobalVisionServer/global_vision_server_module.cpp b/source/RemoteServers/GlobalVisionServer/global_vision_server_module.cpp
index 363d2eb..ad8a694 100644
--- a/source/RemoteServers/GlobalVisionServer/global_vision_server_module.cpp
+++ b/source/RemoteServers/GlobalVisionServer/global_vision_server_module.cpp
@@ -11,27 +11,9 @@
 #include "Utility/boost_logger.hpp"
 #include "Config/config.hpp"
 #include "Utility/common.hpp"
-#include "EKF-Module/motion_ekf_module.hpp"
-#include "EKF-Module/ball_ekf_module.hpp"
 
 using namespace boost;
 
-
-// for explaination of the math, check motion_module.cpp
-static arma::vec transform(arma::vec origin, float orien, arma::vec point2d) {
-    arma::mat A = wtb_homo_transform(origin, orien); // world to body homogeneous transformation
-    arma::vec p_homo_w = {point2d(0), point2d(1), 1}; // homogeneous point end with a 1 (vector end with a 0)
-    arma::vec p_homo_b = A * p_homo_w; // apply transformation to get the same point represented in the body frame
-    // if division factor is approx. eq to zero
-    if(std::fabs(p_homo_b(2)) < 0.000001) {
-        p_homo_b(2) = 0.000001;
-    }
-    // update setpoint to the setpoint in robot's perspective (cartesean coordinate)
-    arma::vec p_cart_b = {p_homo_b(0)/p_homo_b(2), p_homo_b(1)/p_homo_b(2)}; // the division is to divide the scaling factor, according to rules of homogeneous coord systems
-    return p_cart_b;
-}
-
-
 void GlobalVisionServer::task(ThreadPool& thread_pool)
 {
     B_Log logger;
@@ -42,78 +24,47 @@ void GlobalVisionServer::task(ThreadPool& thread_pool)
     asio::io_service io_service;
     asio::ip::udp::endpoint endpoint_to_listen(asio::ip::udp::v4(), GVISION_SERVER_PORT);
     asio::ip::udp::socket socket(io_service, endpoint_to_listen);
-    
-    boost::array<char, UDP_RBUF_SIZE> receive_buffer;
 
     /*** Publisher setup ***/
-    // Note: will convert received worldframe data to body frame in which bot position is relative to the bot origin
-    ITPS::NonBlockingPublisher<arma::vec> trans_disp_pub("GVision Server", "BotPos(BodyFrame)", zero_vec_2d()); 
-    ITPS::NonBlockingPublisher<arma::vec> trans_vel_pub("GVision Server", "BotVel(BodyFrame)", zero_vec_2d());
-    ITPS::NonBlockingPublisher<float> rot_disp_pub("GVision Server", "BotAng(BodyFrame)", 0.00);
-    ITPS::NonBlockingPublisher<float> rot_vel_pub("GVision Server", "BotAngVel(BodyFrame)", 0.00);
-    ITPS::NonBlockingPublisher<arma::vec> ball_loc_pub("GVision Server", "BallPos(BodyFrame)", zero_vec_2d()); 
-    ITPS::NonBlockingPublisher<arma::vec> ball_vel_pub("GVision Server", "BallVel(BodyFrame)", zero_vec_2d());
-
-    /*** Subscriber setup ***/
-    ITPS::NonBlockingSubscriber<arma::vec> robot_origin_w_sub("ConnectionInit", "RobotOrigin(WorldFrame)");
-    ITPS::NonBlockingSubscriber<MotionEKF::MotionData> sensor_sub("MotionEKF", "MotionData");
-    try {
-        robot_origin_w_sub.subscribe(DEFAULT_SUBSCRIBER_TIMEOUT);
-        sensor_sub.subscribe(DEFAULT_SUBSCRIBER_TIMEOUT);
-    }
-    catch(std::exception& e) {
-        B_Log logger;
-        logger.add_tag("[global_vision_server_module.cpp]");
-        logger.log(Error, e.what());
-        std::exit(0);
-    }
-
-    logger.log(Info, "Server Started on Port Number:" + repr(GVISION_SERVER_PORT) 
+    //ITPS::NonBlockingPublisher<std::string> world_data_pub("GlobalVisionServer", "WorldData");
+    ITPS::BlockingPublisher<VisionData> world_data_pub("GlobalVisionServer", "WorldData");
+    
+    
+    logger.log(Info, "Started on Port Number:" + repr(GVISION_SERVER_PORT)
                 + ", Receiving Global Vision Data");
 
-    size_t num_received;
-    std::string packet_received;
-    VisionData visDataReceived;
-    arma::vec trans_disp, trans_vel, ball_loc, ball_vel;
-    float rot_disp, rot_vel; 
     try{
         while(true){
+            size_t num_received;
+            boost::array<char, 1024> receive_buffer;
             num_received = socket.receive_from(boost::asio::buffer(receive_buffer), endpoint_to_listen);
 
+            std::string packet_received;
             packet_received = std::string(receive_buffer.begin(), receive_buffer.begin() + num_received);
             
-
-            //logger.log(Info, "Data received\n");
-            
-            visDataReceived.ParseFromString(packet_received);
-
-            // logger.log(Info, visDataReceived.ball_pos().DebugString());
-
-            /*** Data type & format & ref frame conversions ***/
-            // make local copies
-            trans_disp = {visDataReceived.bot_pos().x(), visDataReceived.bot_pos().y()}; // not transformed yet
-            trans_vel = {visDataReceived.bot_vel().x(), visDataReceived.bot_vel().y()}; // not transformed yet
-            rot_disp = visDataReceived.bot_ang(); // angular data no need to transform
-            rot_vel = visDataReceived.bot_ang_vel(); // angular data no need to transform
-            ball_loc = {visDataReceived.ball_pos().x(), visDataReceived.ball_pos().y()}; // not transformed yet
-            ball_vel = {visDataReceived.ball_vel().x(), visDataReceived.ball_vel().y()}; // not transformed yet
-
-            // reference frame transformation math 
-            arma::vec bot_origin = robot_origin_w_sub.latest_msg();
-            float bot_orien = sensor_sub.latest_msg().rotat_disp;
-            trans_disp = transform(bot_origin, bot_orien, trans_disp);
-            trans_vel = transform(bot_origin, bot_orien, trans_vel);
-            ball_loc = transform(bot_origin, bot_orien, ball_loc);
-            ball_vel = transform(bot_origin, bot_orien, ball_vel);
-            
-            
-
-            trans_disp_pub.publish(trans_disp);
-            trans_vel_pub.publish(trans_vel);
-            rot_disp_pub.publish(rot_disp);
-            rot_vel_pub.publish(rot_vel);
-            ball_loc_pub.publish(ball_loc);
-            ball_vel_pub.publish(ball_vel);
+            // TODO: remove delimiter... I dont know if we still need this since changed to UDP
+            // data.erase(--data.end()); 
+            // ANS: not need to worry about delimiter because UDP doesn't need delimiter to identify packet length
+
+            logger.log(Info, "Data received\n");
+            VisionData visDataReceived;
+            if(!visDataReceived.ParseFromString(packet_received)){
+                logger.log(Error, "[Global Vision Server]: Vision data parsing failed!" );
+                delay(100);
+                continue;
+            }
+
+            if(true){
+                logger.log(Info, "[Global Vision Server]:" + visDataReceived.DebugString());
+                delay(100);
+            }
+
+            world_data_pub.publish(visDataReceived); // publish serialized data
+
+            visDataReceived.release_ball_pos();
+            visDataReceived.release_ball_vel();
+            visDataReceived.release_bot_pos();
+            visDataReceived.release_bot_vel();
 
         }   
     }
diff --git a/source/RemoteServers/RemoteCMDServer/cmd_server_module.cpp b/source/RemoteServers/RemoteCMDServer/cmd_server_module.cpp
index dc465bf..631b002 100644
--- a/source/RemoteServers/RemoteCMDServer/cmd_server_module.cpp
+++ b/source/RemoteServers/RemoteCMDServer/cmd_server_module.cpp
@@ -28,7 +28,7 @@ static Motion::MotionCMD default_cmd() {
 }
 
 // Implementation of task to be run on this thread
-void CMDServer::task(ThreadPool& thread_pool) {
+[[noreturn]] void CMDServer::task(ThreadPool& thread_pool) {
     UNUSED(thread_pool); 
 
     B_Log logger;
@@ -62,7 +62,7 @@ void CMDServer::task(ThreadPool& thread_pool) {
     Motion::MotionCMD m_cmd;
     arma::vec kick_vec2d = {0, 0};
 
-    while(1) {
+    while(true) {
         num_received = socket.receive_from(asio::buffer(receive_buffer), ep_listen);
         packet_received = std::string(receive_buffer.begin(), receive_buffer.begin() + num_received);
         // logger.log(Info, packet_received);
@@ -70,7 +70,7 @@ void CMDServer::task(ThreadPool& thread_pool) {
 
         // logger.log(Debug, cmd.DebugString());
 
-        if(cmd.enable_ball_auto_capture() == false) {
+        if(!cmd.enable_ball_auto_capture()) {
             drib_enable_pub.publish(false);
             // Listening to remote motion commands
             switch((int)cmd.mode()) {
