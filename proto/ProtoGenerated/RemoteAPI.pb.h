// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RemoteAPI.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_RemoteAPI_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_RemoteAPI_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_RemoteAPI_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_RemoteAPI_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_RemoteAPI_2eproto;
class Commands;
class CommandsDefaultTypeInternal;
extern CommandsDefaultTypeInternal _Commands_default_instance_;
class RemoteGeometry;
class RemoteGeometryDefaultTypeInternal;
extern RemoteGeometryDefaultTypeInternal _RemoteGeometry_default_instance_;
class RobotInternalData;
class RobotInternalDataDefaultTypeInternal;
extern RobotInternalDataDefaultTypeInternal _RobotInternalData_default_instance_;
class Vec2D;
class Vec2DDefaultTypeInternal;
extern Vec2DDefaultTypeInternal _Vec2D_default_instance_;
class Vec3D;
class Vec3DDefaultTypeInternal;
extern Vec3DDefaultTypeInternal _Vec3D_default_instance_;
class VisionData;
class VisionDataDefaultTypeInternal;
extern VisionDataDefaultTypeInternal _VisionData_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Commands* Arena::CreateMaybeMessage<::Commands>(Arena*);
template<> ::RemoteGeometry* Arena::CreateMaybeMessage<::RemoteGeometry>(Arena*);
template<> ::RobotInternalData* Arena::CreateMaybeMessage<::RobotInternalData>(Arena*);
template<> ::Vec2D* Arena::CreateMaybeMessage<::Vec2D>(Arena*);
template<> ::Vec3D* Arena::CreateMaybeMessage<::Vec3D>(Arena*);
template<> ::VisionData* Arena::CreateMaybeMessage<::VisionData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Vec2D PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Vec2D) */ {
 public:
  inline Vec2D() : Vec2D(nullptr) {};
  virtual ~Vec2D();

  Vec2D(const Vec2D& from);
  Vec2D(Vec2D&& from) noexcept
    : Vec2D() {
    *this = ::std::move(from);
  }

  inline Vec2D& operator=(const Vec2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2D& operator=(Vec2D&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec2D* internal_default_instance() {
    return reinterpret_cast<const Vec2D*>(
               &_Vec2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vec2D& a, Vec2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2D* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2D* New() const final {
    return CreateMaybeMessage<Vec2D>(nullptr);
  }

  Vec2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec2D& from);
  void MergeFrom(const Vec2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Vec2D";
  }
  protected:
  explicit Vec2D(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RemoteAPI_2eproto);
    return ::descriptor_table_RemoteAPI_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:Vec2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_RemoteAPI_2eproto;
};
// -------------------------------------------------------------------

class Vec3D PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Vec3D) */ {
 public:
  inline Vec3D() : Vec3D(nullptr) {};
  virtual ~Vec3D();

  Vec3D(const Vec3D& from);
  Vec3D(Vec3D&& from) noexcept
    : Vec3D() {
    *this = ::std::move(from);
  }

  inline Vec3D& operator=(const Vec3D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3D& operator=(Vec3D&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec3D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec3D* internal_default_instance() {
    return reinterpret_cast<const Vec3D*>(
               &_Vec3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vec3D& a, Vec3D& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3D* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec3D* New() const final {
    return CreateMaybeMessage<Vec3D>(nullptr);
  }

  Vec3D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec3D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec3D& from);
  void MergeFrom(const Vec3D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Vec3D";
  }
  protected:
  explicit Vec3D(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RemoteAPI_2eproto);
    return ::descriptor_table_RemoteAPI_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:Vec3D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_RemoteAPI_2eproto;
};
// -------------------------------------------------------------------

class RemoteGeometry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoteGeometry) */ {
 public:
  inline RemoteGeometry() : RemoteGeometry(nullptr) {};
  virtual ~RemoteGeometry();

  RemoteGeometry(const RemoteGeometry& from);
  RemoteGeometry(RemoteGeometry&& from) noexcept
    : RemoteGeometry() {
    *this = ::std::move(from);
  }

  inline RemoteGeometry& operator=(const RemoteGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteGeometry& operator=(RemoteGeometry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteGeometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteGeometry* internal_default_instance() {
    return reinterpret_cast<const RemoteGeometry*>(
               &_RemoteGeometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RemoteGeometry& a, RemoteGeometry& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteGeometry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteGeometry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteGeometry* New() const final {
    return CreateMaybeMessage<RemoteGeometry>(nullptr);
  }

  RemoteGeometry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteGeometry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteGeometry& from);
  void MergeFrom(const RemoteGeometry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteGeometry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoteGeometry";
  }
  protected:
  explicit RemoteGeometry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RemoteAPI_2eproto);
    return ::descriptor_table_RemoteAPI_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldLengthFieldNumber = 1,
    kFieldWidthFieldNumber = 2,
    kGoalWidthFieldNumber = 3,
    kGoalDepthFieldNumber = 4,
  };
  // int32 field_length = 1;
  void clear_field_length();
  ::PROTOBUF_NAMESPACE_ID::int32 field_length() const;
  void set_field_length(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field_length() const;
  void _internal_set_field_length(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 field_width = 2;
  void clear_field_width();
  ::PROTOBUF_NAMESPACE_ID::int32 field_width() const;
  void set_field_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field_width() const;
  void _internal_set_field_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 goal_width = 3;
  void clear_goal_width();
  ::PROTOBUF_NAMESPACE_ID::int32 goal_width() const;
  void set_goal_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_goal_width() const;
  void _internal_set_goal_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 goal_depth = 4;
  void clear_goal_depth();
  ::PROTOBUF_NAMESPACE_ID::int32 goal_depth() const;
  void set_goal_depth(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_goal_depth() const;
  void _internal_set_goal_depth(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:RemoteGeometry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 field_length_;
  ::PROTOBUF_NAMESPACE_ID::int32 field_width_;
  ::PROTOBUF_NAMESPACE_ID::int32 goal_width_;
  ::PROTOBUF_NAMESPACE_ID::int32 goal_depth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_RemoteAPI_2eproto;
};
// -------------------------------------------------------------------

class Commands PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Commands) */ {
 public:
  inline Commands() : Commands(nullptr) {};
  virtual ~Commands();

  Commands(const Commands& from);
  Commands(Commands&& from) noexcept
    : Commands() {
    *this = ::std::move(from);
  }

  inline Commands& operator=(const Commands& from) {
    CopyFrom(from);
    return *this;
  }
  inline Commands& operator=(Commands&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Commands& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Commands* internal_default_instance() {
    return reinterpret_cast<const Commands*>(
               &_Commands_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Commands& a, Commands& b) {
    a.Swap(&b);
  }
  inline void Swap(Commands* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Commands* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Commands* New() const final {
    return CreateMaybeMessage<Commands>(nullptr);
  }

  Commands* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Commands>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Commands& from);
  void MergeFrom(const Commands& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Commands* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Commands";
  }
  protected:
  explicit Commands(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RemoteAPI_2eproto);
    return ::descriptor_table_RemoteAPI_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotionSetPointFieldNumber = 4,
    kKickerSetPointFieldNumber = 5,
    kModeFieldNumber = 2,
    kEnableBallAutoCaptureFieldNumber = 1,
    kIsWorldFrameFieldNumber = 3,
  };
  // .Vec3D motion_set_point = 4;
  bool has_motion_set_point() const;
  private:
  bool _internal_has_motion_set_point() const;
  public:
  void clear_motion_set_point();
  const ::Vec3D& motion_set_point() const;
  ::Vec3D* release_motion_set_point();
  ::Vec3D* mutable_motion_set_point();
  void set_allocated_motion_set_point(::Vec3D* motion_set_point);
  private:
  const ::Vec3D& _internal_motion_set_point() const;
  ::Vec3D* _internal_mutable_motion_set_point();
  public:
  void unsafe_arena_set_allocated_motion_set_point(
      ::Vec3D* motion_set_point);
  ::Vec3D* unsafe_arena_release_motion_set_point();

  // .Vec3D kicker_set_point = 5;
  bool has_kicker_set_point() const;
  private:
  bool _internal_has_kicker_set_point() const;
  public:
  void clear_kicker_set_point();
  const ::Vec3D& kicker_set_point() const;
  ::Vec3D* release_kicker_set_point();
  ::Vec3D* mutable_kicker_set_point();
  void set_allocated_kicker_set_point(::Vec3D* kicker_set_point);
  private:
  const ::Vec3D& _internal_kicker_set_point() const;
  ::Vec3D* _internal_mutable_kicker_set_point();
  public:
  void unsafe_arena_set_allocated_kicker_set_point(
      ::Vec3D* kicker_set_point);
  ::Vec3D* unsafe_arena_release_kicker_set_point();

  // int32 mode = 2;
  void clear_mode();
  ::PROTOBUF_NAMESPACE_ID::int32 mode() const;
  void set_mode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mode() const;
  void _internal_set_mode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool enable_ball_auto_capture = 1;
  void clear_enable_ball_auto_capture();
  bool enable_ball_auto_capture() const;
  void set_enable_ball_auto_capture(bool value);
  private:
  bool _internal_enable_ball_auto_capture() const;
  void _internal_set_enable_ball_auto_capture(bool value);
  public:

  // bool is_world_frame = 3;
  void clear_is_world_frame();
  bool is_world_frame() const;
  void set_is_world_frame(bool value);
  private:
  bool _internal_is_world_frame() const;
  void _internal_set_is_world_frame(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Commands)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Vec3D* motion_set_point_;
  ::Vec3D* kicker_set_point_;
  ::PROTOBUF_NAMESPACE_ID::int32 mode_;
  bool enable_ball_auto_capture_;
  bool is_world_frame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_RemoteAPI_2eproto;
};
// -------------------------------------------------------------------

class RobotInternalData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RobotInternalData) */ {
 public:
  inline RobotInternalData() : RobotInternalData(nullptr) {};
  virtual ~RobotInternalData();

  RobotInternalData(const RobotInternalData& from);
  RobotInternalData(RobotInternalData&& from) noexcept
    : RobotInternalData() {
    *this = ::std::move(from);
  }

  inline RobotInternalData& operator=(const RobotInternalData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotInternalData& operator=(RobotInternalData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotInternalData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotInternalData* internal_default_instance() {
    return reinterpret_cast<const RobotInternalData*>(
               &_RobotInternalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RobotInternalData& a, RobotInternalData& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotInternalData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotInternalData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotInternalData* New() const final {
    return CreateMaybeMessage<RobotInternalData>(nullptr);
  }

  RobotInternalData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotInternalData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotInternalData& from);
  void MergeFrom(const RobotInternalData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotInternalData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RobotInternalData";
  }
  protected:
  explicit RobotInternalData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RemoteAPI_2eproto);
    return ::descriptor_table_RemoteAPI_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransVelFieldNumber = 1,
    kTransDispFieldNumber = 2,
    kRotatVelFieldNumber = 3,
    kRotatDispFieldNumber = 4,
  };
  // .Vec2D trans_vel = 1;
  bool has_trans_vel() const;
  private:
  bool _internal_has_trans_vel() const;
  public:
  void clear_trans_vel();
  const ::Vec2D& trans_vel() const;
  ::Vec2D* release_trans_vel();
  ::Vec2D* mutable_trans_vel();
  void set_allocated_trans_vel(::Vec2D* trans_vel);
  private:
  const ::Vec2D& _internal_trans_vel() const;
  ::Vec2D* _internal_mutable_trans_vel();
  public:
  void unsafe_arena_set_allocated_trans_vel(
      ::Vec2D* trans_vel);
  ::Vec2D* unsafe_arena_release_trans_vel();

  // .Vec2D trans_disp = 2;
  bool has_trans_disp() const;
  private:
  bool _internal_has_trans_disp() const;
  public:
  void clear_trans_disp();
  const ::Vec2D& trans_disp() const;
  ::Vec2D* release_trans_disp();
  ::Vec2D* mutable_trans_disp();
  void set_allocated_trans_disp(::Vec2D* trans_disp);
  private:
  const ::Vec2D& _internal_trans_disp() const;
  ::Vec2D* _internal_mutable_trans_disp();
  public:
  void unsafe_arena_set_allocated_trans_disp(
      ::Vec2D* trans_disp);
  ::Vec2D* unsafe_arena_release_trans_disp();

  // double rotat_vel = 3;
  void clear_rotat_vel();
  double rotat_vel() const;
  void set_rotat_vel(double value);
  private:
  double _internal_rotat_vel() const;
  void _internal_set_rotat_vel(double value);
  public:

  // double rotat_disp = 4;
  void clear_rotat_disp();
  double rotat_disp() const;
  void set_rotat_disp(double value);
  private:
  double _internal_rotat_disp() const;
  void _internal_set_rotat_disp(double value);
  public:

  // @@protoc_insertion_point(class_scope:RobotInternalData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Vec2D* trans_vel_;
  ::Vec2D* trans_disp_;
  double rotat_vel_;
  double rotat_disp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_RemoteAPI_2eproto;
};
// -------------------------------------------------------------------

class VisionData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VisionData) */ {
 public:
  inline VisionData() : VisionData(nullptr) {};
  virtual ~VisionData();

  VisionData(const VisionData& from);
  VisionData(VisionData&& from) noexcept
    : VisionData() {
    *this = ::std::move(from);
  }

  inline VisionData& operator=(const VisionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionData& operator=(VisionData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VisionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VisionData* internal_default_instance() {
    return reinterpret_cast<const VisionData*>(
               &_VisionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VisionData& a, VisionData& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VisionData* New() const final {
    return CreateMaybeMessage<VisionData>(nullptr);
  }

  VisionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VisionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VisionData& from);
  void MergeFrom(const VisionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VisionData";
  }
  protected:
  explicit VisionData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RemoteAPI_2eproto);
    return ::descriptor_table_RemoteAPI_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBotPosFieldNumber = 1,
    kBotVelFieldNumber = 2,
    kBallPosFieldNumber = 5,
    kBallVelFieldNumber = 6,
    kBotAngFieldNumber = 3,
    kBotAngVelFieldNumber = 4,
  };
  // .Vec2D bot_pos = 1;
  bool has_bot_pos() const;
  private:
  bool _internal_has_bot_pos() const;
  public:
  void clear_bot_pos();
  const ::Vec2D& bot_pos() const;
  ::Vec2D* release_bot_pos();
  ::Vec2D* mutable_bot_pos();
  void set_allocated_bot_pos(::Vec2D* bot_pos);
  private:
  const ::Vec2D& _internal_bot_pos() const;
  ::Vec2D* _internal_mutable_bot_pos();
  public:
  void unsafe_arena_set_allocated_bot_pos(
      ::Vec2D* bot_pos);
  ::Vec2D* unsafe_arena_release_bot_pos();

  // .Vec2D bot_vel = 2;
  bool has_bot_vel() const;
  private:
  bool _internal_has_bot_vel() const;
  public:
  void clear_bot_vel();
  const ::Vec2D& bot_vel() const;
  ::Vec2D* release_bot_vel();
  ::Vec2D* mutable_bot_vel();
  void set_allocated_bot_vel(::Vec2D* bot_vel);
  private:
  const ::Vec2D& _internal_bot_vel() const;
  ::Vec2D* _internal_mutable_bot_vel();
  public:
  void unsafe_arena_set_allocated_bot_vel(
      ::Vec2D* bot_vel);
  ::Vec2D* unsafe_arena_release_bot_vel();

  // .Vec2D ball_pos = 5;
  bool has_ball_pos() const;
  private:
  bool _internal_has_ball_pos() const;
  public:
  void clear_ball_pos();
  const ::Vec2D& ball_pos() const;
  ::Vec2D* release_ball_pos();
  ::Vec2D* mutable_ball_pos();
  void set_allocated_ball_pos(::Vec2D* ball_pos);
  private:
  const ::Vec2D& _internal_ball_pos() const;
  ::Vec2D* _internal_mutable_ball_pos();
  public:
  void unsafe_arena_set_allocated_ball_pos(
      ::Vec2D* ball_pos);
  ::Vec2D* unsafe_arena_release_ball_pos();

  // .Vec2D ball_vel = 6;
  bool has_ball_vel() const;
  private:
  bool _internal_has_ball_vel() const;
  public:
  void clear_ball_vel();
  const ::Vec2D& ball_vel() const;
  ::Vec2D* release_ball_vel();
  ::Vec2D* mutable_ball_vel();
  void set_allocated_ball_vel(::Vec2D* ball_vel);
  private:
  const ::Vec2D& _internal_ball_vel() const;
  ::Vec2D* _internal_mutable_ball_vel();
  public:
  void unsafe_arena_set_allocated_ball_vel(
      ::Vec2D* ball_vel);
  ::Vec2D* unsafe_arena_release_ball_vel();

  // double bot_ang = 3;
  void clear_bot_ang();
  double bot_ang() const;
  void set_bot_ang(double value);
  private:
  double _internal_bot_ang() const;
  void _internal_set_bot_ang(double value);
  public:

  // double bot_ang_vel = 4;
  void clear_bot_ang_vel();
  double bot_ang_vel() const;
  void set_bot_ang_vel(double value);
  private:
  double _internal_bot_ang_vel() const;
  void _internal_set_bot_ang_vel(double value);
  public:

  // @@protoc_insertion_point(class_scope:VisionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Vec2D* bot_pos_;
  ::Vec2D* bot_vel_;
  ::Vec2D* ball_pos_;
  ::Vec2D* ball_vel_;
  double bot_ang_;
  double bot_ang_vel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_RemoteAPI_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vec2D

// double x = 1;
inline void Vec2D::clear_x() {
  x_ = 0;
}
inline double Vec2D::_internal_x() const {
  return x_;
}
inline double Vec2D::x() const {
  // @@protoc_insertion_point(field_get:Vec2D.x)
  return _internal_x();
}
inline void Vec2D::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Vec2D::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Vec2D.x)
}

// double y = 2;
inline void Vec2D::clear_y() {
  y_ = 0;
}
inline double Vec2D::_internal_y() const {
  return y_;
}
inline double Vec2D::y() const {
  // @@protoc_insertion_point(field_get:Vec2D.y)
  return _internal_y();
}
inline void Vec2D::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Vec2D::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Vec2D.y)
}

// -------------------------------------------------------------------

// Vec3D

// double x = 1;
inline void Vec3D::clear_x() {
  x_ = 0;
}
inline double Vec3D::_internal_x() const {
  return x_;
}
inline double Vec3D::x() const {
  // @@protoc_insertion_point(field_get:Vec3D.x)
  return _internal_x();
}
inline void Vec3D::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Vec3D::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Vec3D.x)
}

// double y = 2;
inline void Vec3D::clear_y() {
  y_ = 0;
}
inline double Vec3D::_internal_y() const {
  return y_;
}
inline double Vec3D::y() const {
  // @@protoc_insertion_point(field_get:Vec3D.y)
  return _internal_y();
}
inline void Vec3D::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Vec3D::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Vec3D.y)
}

// double z = 3;
inline void Vec3D::clear_z() {
  z_ = 0;
}
inline double Vec3D::_internal_z() const {
  return z_;
}
inline double Vec3D::z() const {
  // @@protoc_insertion_point(field_get:Vec3D.z)
  return _internal_z();
}
inline void Vec3D::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Vec3D::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Vec3D.z)
}

// -------------------------------------------------------------------

// RemoteGeometry

// int32 field_length = 1;
inline void RemoteGeometry::clear_field_length() {
  field_length_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemoteGeometry::_internal_field_length() const {
  return field_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemoteGeometry::field_length() const {
  // @@protoc_insertion_point(field_get:RemoteGeometry.field_length)
  return _internal_field_length();
}
inline void RemoteGeometry::_internal_set_field_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  field_length_ = value;
}
inline void RemoteGeometry::set_field_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_field_length(value);
  // @@protoc_insertion_point(field_set:RemoteGeometry.field_length)
}

// int32 field_width = 2;
inline void RemoteGeometry::clear_field_width() {
  field_width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemoteGeometry::_internal_field_width() const {
  return field_width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemoteGeometry::field_width() const {
  // @@protoc_insertion_point(field_get:RemoteGeometry.field_width)
  return _internal_field_width();
}
inline void RemoteGeometry::_internal_set_field_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  field_width_ = value;
}
inline void RemoteGeometry::set_field_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_field_width(value);
  // @@protoc_insertion_point(field_set:RemoteGeometry.field_width)
}

// int32 goal_width = 3;
inline void RemoteGeometry::clear_goal_width() {
  goal_width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemoteGeometry::_internal_goal_width() const {
  return goal_width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemoteGeometry::goal_width() const {
  // @@protoc_insertion_point(field_get:RemoteGeometry.goal_width)
  return _internal_goal_width();
}
inline void RemoteGeometry::_internal_set_goal_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  goal_width_ = value;
}
inline void RemoteGeometry::set_goal_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_goal_width(value);
  // @@protoc_insertion_point(field_set:RemoteGeometry.goal_width)
}

// int32 goal_depth = 4;
inline void RemoteGeometry::clear_goal_depth() {
  goal_depth_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemoteGeometry::_internal_goal_depth() const {
  return goal_depth_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemoteGeometry::goal_depth() const {
  // @@protoc_insertion_point(field_get:RemoteGeometry.goal_depth)
  return _internal_goal_depth();
}
inline void RemoteGeometry::_internal_set_goal_depth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  goal_depth_ = value;
}
inline void RemoteGeometry::set_goal_depth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_goal_depth(value);
  // @@protoc_insertion_point(field_set:RemoteGeometry.goal_depth)
}

// -------------------------------------------------------------------

// Commands

// bool enable_ball_auto_capture = 1;
inline void Commands::clear_enable_ball_auto_capture() {
  enable_ball_auto_capture_ = false;
}
inline bool Commands::_internal_enable_ball_auto_capture() const {
  return enable_ball_auto_capture_;
}
inline bool Commands::enable_ball_auto_capture() const {
  // @@protoc_insertion_point(field_get:Commands.enable_ball_auto_capture)
  return _internal_enable_ball_auto_capture();
}
inline void Commands::_internal_set_enable_ball_auto_capture(bool value) {
  
  enable_ball_auto_capture_ = value;
}
inline void Commands::set_enable_ball_auto_capture(bool value) {
  _internal_set_enable_ball_auto_capture(value);
  // @@protoc_insertion_point(field_set:Commands.enable_ball_auto_capture)
}

// int32 mode = 2;
inline void Commands::clear_mode() {
  mode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Commands::_internal_mode() const {
  return mode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Commands::mode() const {
  // @@protoc_insertion_point(field_get:Commands.mode)
  return _internal_mode();
}
inline void Commands::_internal_set_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  mode_ = value;
}
inline void Commands::set_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:Commands.mode)
}

// bool is_world_frame = 3;
inline void Commands::clear_is_world_frame() {
  is_world_frame_ = false;
}
inline bool Commands::_internal_is_world_frame() const {
  return is_world_frame_;
}
inline bool Commands::is_world_frame() const {
  // @@protoc_insertion_point(field_get:Commands.is_world_frame)
  return _internal_is_world_frame();
}
inline void Commands::_internal_set_is_world_frame(bool value) {
  
  is_world_frame_ = value;
}
inline void Commands::set_is_world_frame(bool value) {
  _internal_set_is_world_frame(value);
  // @@protoc_insertion_point(field_set:Commands.is_world_frame)
}

// .Vec3D motion_set_point = 4;
inline bool Commands::_internal_has_motion_set_point() const {
  return this != internal_default_instance() && motion_set_point_ != nullptr;
}
inline bool Commands::has_motion_set_point() const {
  return _internal_has_motion_set_point();
}
inline void Commands::clear_motion_set_point() {
  if (GetArena() == nullptr && motion_set_point_ != nullptr) {
    delete motion_set_point_;
  }
  motion_set_point_ = nullptr;
}
inline const ::Vec3D& Commands::_internal_motion_set_point() const {
  const ::Vec3D* p = motion_set_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec3D*>(
      &::_Vec3D_default_instance_);
}
inline const ::Vec3D& Commands::motion_set_point() const {
  // @@protoc_insertion_point(field_get:Commands.motion_set_point)
  return _internal_motion_set_point();
}
inline void Commands::unsafe_arena_set_allocated_motion_set_point(
    ::Vec3D* motion_set_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motion_set_point_);
  }
  motion_set_point_ = motion_set_point;
  if (motion_set_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Commands.motion_set_point)
}
inline ::Vec3D* Commands::release_motion_set_point() {
  auto temp = unsafe_arena_release_motion_set_point();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Vec3D* Commands::unsafe_arena_release_motion_set_point() {
  // @@protoc_insertion_point(field_release:Commands.motion_set_point)
  
  ::Vec3D* temp = motion_set_point_;
  motion_set_point_ = nullptr;
  return temp;
}
inline ::Vec3D* Commands::_internal_mutable_motion_set_point() {
  
  if (motion_set_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec3D>(GetArena());
    motion_set_point_ = p;
  }
  return motion_set_point_;
}
inline ::Vec3D* Commands::mutable_motion_set_point() {
  // @@protoc_insertion_point(field_mutable:Commands.motion_set_point)
  return _internal_mutable_motion_set_point();
}
inline void Commands::set_allocated_motion_set_point(::Vec3D* motion_set_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete motion_set_point_;
  }
  if (motion_set_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(motion_set_point);
    if (message_arena != submessage_arena) {
      motion_set_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motion_set_point, submessage_arena);
    }
    
  } else {
    
  }
  motion_set_point_ = motion_set_point;
  // @@protoc_insertion_point(field_set_allocated:Commands.motion_set_point)
}

// .Vec3D kicker_set_point = 5;
inline bool Commands::_internal_has_kicker_set_point() const {
  return this != internal_default_instance() && kicker_set_point_ != nullptr;
}
inline bool Commands::has_kicker_set_point() const {
  return _internal_has_kicker_set_point();
}
inline void Commands::clear_kicker_set_point() {
  if (GetArena() == nullptr && kicker_set_point_ != nullptr) {
    delete kicker_set_point_;
  }
  kicker_set_point_ = nullptr;
}
inline const ::Vec3D& Commands::_internal_kicker_set_point() const {
  const ::Vec3D* p = kicker_set_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec3D*>(
      &::_Vec3D_default_instance_);
}
inline const ::Vec3D& Commands::kicker_set_point() const {
  // @@protoc_insertion_point(field_get:Commands.kicker_set_point)
  return _internal_kicker_set_point();
}
inline void Commands::unsafe_arena_set_allocated_kicker_set_point(
    ::Vec3D* kicker_set_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kicker_set_point_);
  }
  kicker_set_point_ = kicker_set_point;
  if (kicker_set_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Commands.kicker_set_point)
}
inline ::Vec3D* Commands::release_kicker_set_point() {
  auto temp = unsafe_arena_release_kicker_set_point();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Vec3D* Commands::unsafe_arena_release_kicker_set_point() {
  // @@protoc_insertion_point(field_release:Commands.kicker_set_point)
  
  ::Vec3D* temp = kicker_set_point_;
  kicker_set_point_ = nullptr;
  return temp;
}
inline ::Vec3D* Commands::_internal_mutable_kicker_set_point() {
  
  if (kicker_set_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec3D>(GetArena());
    kicker_set_point_ = p;
  }
  return kicker_set_point_;
}
inline ::Vec3D* Commands::mutable_kicker_set_point() {
  // @@protoc_insertion_point(field_mutable:Commands.kicker_set_point)
  return _internal_mutable_kicker_set_point();
}
inline void Commands::set_allocated_kicker_set_point(::Vec3D* kicker_set_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete kicker_set_point_;
  }
  if (kicker_set_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(kicker_set_point);
    if (message_arena != submessage_arena) {
      kicker_set_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kicker_set_point, submessage_arena);
    }
    
  } else {
    
  }
  kicker_set_point_ = kicker_set_point;
  // @@protoc_insertion_point(field_set_allocated:Commands.kicker_set_point)
}

// -------------------------------------------------------------------

// RobotInternalData

// .Vec2D trans_vel = 1;
inline bool RobotInternalData::_internal_has_trans_vel() const {
  return this != internal_default_instance() && trans_vel_ != nullptr;
}
inline bool RobotInternalData::has_trans_vel() const {
  return _internal_has_trans_vel();
}
inline void RobotInternalData::clear_trans_vel() {
  if (GetArena() == nullptr && trans_vel_ != nullptr) {
    delete trans_vel_;
  }
  trans_vel_ = nullptr;
}
inline const ::Vec2D& RobotInternalData::_internal_trans_vel() const {
  const ::Vec2D* p = trans_vel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec2D*>(
      &::_Vec2D_default_instance_);
}
inline const ::Vec2D& RobotInternalData::trans_vel() const {
  // @@protoc_insertion_point(field_get:RobotInternalData.trans_vel)
  return _internal_trans_vel();
}
inline void RobotInternalData::unsafe_arena_set_allocated_trans_vel(
    ::Vec2D* trans_vel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trans_vel_);
  }
  trans_vel_ = trans_vel;
  if (trans_vel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RobotInternalData.trans_vel)
}
inline ::Vec2D* RobotInternalData::release_trans_vel() {
  auto temp = unsafe_arena_release_trans_vel();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Vec2D* RobotInternalData::unsafe_arena_release_trans_vel() {
  // @@protoc_insertion_point(field_release:RobotInternalData.trans_vel)
  
  ::Vec2D* temp = trans_vel_;
  trans_vel_ = nullptr;
  return temp;
}
inline ::Vec2D* RobotInternalData::_internal_mutable_trans_vel() {
  
  if (trans_vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec2D>(GetArena());
    trans_vel_ = p;
  }
  return trans_vel_;
}
inline ::Vec2D* RobotInternalData::mutable_trans_vel() {
  // @@protoc_insertion_point(field_mutable:RobotInternalData.trans_vel)
  return _internal_mutable_trans_vel();
}
inline void RobotInternalData::set_allocated_trans_vel(::Vec2D* trans_vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete trans_vel_;
  }
  if (trans_vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(trans_vel);
    if (message_arena != submessage_arena) {
      trans_vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trans_vel, submessage_arena);
    }
    
  } else {
    
  }
  trans_vel_ = trans_vel;
  // @@protoc_insertion_point(field_set_allocated:RobotInternalData.trans_vel)
}

// .Vec2D trans_disp = 2;
inline bool RobotInternalData::_internal_has_trans_disp() const {
  return this != internal_default_instance() && trans_disp_ != nullptr;
}
inline bool RobotInternalData::has_trans_disp() const {
  return _internal_has_trans_disp();
}
inline void RobotInternalData::clear_trans_disp() {
  if (GetArena() == nullptr && trans_disp_ != nullptr) {
    delete trans_disp_;
  }
  trans_disp_ = nullptr;
}
inline const ::Vec2D& RobotInternalData::_internal_trans_disp() const {
  const ::Vec2D* p = trans_disp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec2D*>(
      &::_Vec2D_default_instance_);
}
inline const ::Vec2D& RobotInternalData::trans_disp() const {
  // @@protoc_insertion_point(field_get:RobotInternalData.trans_disp)
  return _internal_trans_disp();
}
inline void RobotInternalData::unsafe_arena_set_allocated_trans_disp(
    ::Vec2D* trans_disp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trans_disp_);
  }
  trans_disp_ = trans_disp;
  if (trans_disp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RobotInternalData.trans_disp)
}
inline ::Vec2D* RobotInternalData::release_trans_disp() {
  auto temp = unsafe_arena_release_trans_disp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Vec2D* RobotInternalData::unsafe_arena_release_trans_disp() {
  // @@protoc_insertion_point(field_release:RobotInternalData.trans_disp)
  
  ::Vec2D* temp = trans_disp_;
  trans_disp_ = nullptr;
  return temp;
}
inline ::Vec2D* RobotInternalData::_internal_mutable_trans_disp() {
  
  if (trans_disp_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec2D>(GetArena());
    trans_disp_ = p;
  }
  return trans_disp_;
}
inline ::Vec2D* RobotInternalData::mutable_trans_disp() {
  // @@protoc_insertion_point(field_mutable:RobotInternalData.trans_disp)
  return _internal_mutable_trans_disp();
}
inline void RobotInternalData::set_allocated_trans_disp(::Vec2D* trans_disp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete trans_disp_;
  }
  if (trans_disp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(trans_disp);
    if (message_arena != submessage_arena) {
      trans_disp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trans_disp, submessage_arena);
    }
    
  } else {
    
  }
  trans_disp_ = trans_disp;
  // @@protoc_insertion_point(field_set_allocated:RobotInternalData.trans_disp)
}

// double rotat_vel = 3;
inline void RobotInternalData::clear_rotat_vel() {
  rotat_vel_ = 0;
}
inline double RobotInternalData::_internal_rotat_vel() const {
  return rotat_vel_;
}
inline double RobotInternalData::rotat_vel() const {
  // @@protoc_insertion_point(field_get:RobotInternalData.rotat_vel)
  return _internal_rotat_vel();
}
inline void RobotInternalData::_internal_set_rotat_vel(double value) {
  
  rotat_vel_ = value;
}
inline void RobotInternalData::set_rotat_vel(double value) {
  _internal_set_rotat_vel(value);
  // @@protoc_insertion_point(field_set:RobotInternalData.rotat_vel)
}

// double rotat_disp = 4;
inline void RobotInternalData::clear_rotat_disp() {
  rotat_disp_ = 0;
}
inline double RobotInternalData::_internal_rotat_disp() const {
  return rotat_disp_;
}
inline double RobotInternalData::rotat_disp() const {
  // @@protoc_insertion_point(field_get:RobotInternalData.rotat_disp)
  return _internal_rotat_disp();
}
inline void RobotInternalData::_internal_set_rotat_disp(double value) {
  
  rotat_disp_ = value;
}
inline void RobotInternalData::set_rotat_disp(double value) {
  _internal_set_rotat_disp(value);
  // @@protoc_insertion_point(field_set:RobotInternalData.rotat_disp)
}

// -------------------------------------------------------------------

// VisionData

// .Vec2D bot_pos = 1;
inline bool VisionData::_internal_has_bot_pos() const {
  return this != internal_default_instance() && bot_pos_ != nullptr;
}
inline bool VisionData::has_bot_pos() const {
  return _internal_has_bot_pos();
}
inline void VisionData::clear_bot_pos() {
  if (GetArena() == nullptr && bot_pos_ != nullptr) {
    delete bot_pos_;
  }
  bot_pos_ = nullptr;
}
inline const ::Vec2D& VisionData::_internal_bot_pos() const {
  const ::Vec2D* p = bot_pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec2D*>(
      &::_Vec2D_default_instance_);
}
inline const ::Vec2D& VisionData::bot_pos() const {
  // @@protoc_insertion_point(field_get:VisionData.bot_pos)
  return _internal_bot_pos();
}
inline void VisionData::unsafe_arena_set_allocated_bot_pos(
    ::Vec2D* bot_pos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bot_pos_);
  }
  bot_pos_ = bot_pos;
  if (bot_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VisionData.bot_pos)
}
inline ::Vec2D* VisionData::release_bot_pos() {
  auto temp = unsafe_arena_release_bot_pos();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Vec2D* VisionData::unsafe_arena_release_bot_pos() {
  // @@protoc_insertion_point(field_release:VisionData.bot_pos)
  
  ::Vec2D* temp = bot_pos_;
  bot_pos_ = nullptr;
  return temp;
}
inline ::Vec2D* VisionData::_internal_mutable_bot_pos() {
  
  if (bot_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec2D>(GetArena());
    bot_pos_ = p;
  }
  return bot_pos_;
}
inline ::Vec2D* VisionData::mutable_bot_pos() {
  // @@protoc_insertion_point(field_mutable:VisionData.bot_pos)
  return _internal_mutable_bot_pos();
}
inline void VisionData::set_allocated_bot_pos(::Vec2D* bot_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bot_pos_;
  }
  if (bot_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bot_pos);
    if (message_arena != submessage_arena) {
      bot_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bot_pos, submessage_arena);
    }
    
  } else {
    
  }
  bot_pos_ = bot_pos;
  // @@protoc_insertion_point(field_set_allocated:VisionData.bot_pos)
}

// .Vec2D bot_vel = 2;
inline bool VisionData::_internal_has_bot_vel() const {
  return this != internal_default_instance() && bot_vel_ != nullptr;
}
inline bool VisionData::has_bot_vel() const {
  return _internal_has_bot_vel();
}
inline void VisionData::clear_bot_vel() {
  if (GetArena() == nullptr && bot_vel_ != nullptr) {
    delete bot_vel_;
  }
  bot_vel_ = nullptr;
}
inline const ::Vec2D& VisionData::_internal_bot_vel() const {
  const ::Vec2D* p = bot_vel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec2D*>(
      &::_Vec2D_default_instance_);
}
inline const ::Vec2D& VisionData::bot_vel() const {
  // @@protoc_insertion_point(field_get:VisionData.bot_vel)
  return _internal_bot_vel();
}
inline void VisionData::unsafe_arena_set_allocated_bot_vel(
    ::Vec2D* bot_vel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bot_vel_);
  }
  bot_vel_ = bot_vel;
  if (bot_vel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VisionData.bot_vel)
}
inline ::Vec2D* VisionData::release_bot_vel() {
  auto temp = unsafe_arena_release_bot_vel();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Vec2D* VisionData::unsafe_arena_release_bot_vel() {
  // @@protoc_insertion_point(field_release:VisionData.bot_vel)
  
  ::Vec2D* temp = bot_vel_;
  bot_vel_ = nullptr;
  return temp;
}
inline ::Vec2D* VisionData::_internal_mutable_bot_vel() {
  
  if (bot_vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec2D>(GetArena());
    bot_vel_ = p;
  }
  return bot_vel_;
}
inline ::Vec2D* VisionData::mutable_bot_vel() {
  // @@protoc_insertion_point(field_mutable:VisionData.bot_vel)
  return _internal_mutable_bot_vel();
}
inline void VisionData::set_allocated_bot_vel(::Vec2D* bot_vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bot_vel_;
  }
  if (bot_vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bot_vel);
    if (message_arena != submessage_arena) {
      bot_vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bot_vel, submessage_arena);
    }
    
  } else {
    
  }
  bot_vel_ = bot_vel;
  // @@protoc_insertion_point(field_set_allocated:VisionData.bot_vel)
}

// double bot_ang = 3;
inline void VisionData::clear_bot_ang() {
  bot_ang_ = 0;
}
inline double VisionData::_internal_bot_ang() const {
  return bot_ang_;
}
inline double VisionData::bot_ang() const {
  // @@protoc_insertion_point(field_get:VisionData.bot_ang)
  return _internal_bot_ang();
}
inline void VisionData::_internal_set_bot_ang(double value) {
  
  bot_ang_ = value;
}
inline void VisionData::set_bot_ang(double value) {
  _internal_set_bot_ang(value);
  // @@protoc_insertion_point(field_set:VisionData.bot_ang)
}

// double bot_ang_vel = 4;
inline void VisionData::clear_bot_ang_vel() {
  bot_ang_vel_ = 0;
}
inline double VisionData::_internal_bot_ang_vel() const {
  return bot_ang_vel_;
}
inline double VisionData::bot_ang_vel() const {
  // @@protoc_insertion_point(field_get:VisionData.bot_ang_vel)
  return _internal_bot_ang_vel();
}
inline void VisionData::_internal_set_bot_ang_vel(double value) {
  
  bot_ang_vel_ = value;
}
inline void VisionData::set_bot_ang_vel(double value) {
  _internal_set_bot_ang_vel(value);
  // @@protoc_insertion_point(field_set:VisionData.bot_ang_vel)
}

// .Vec2D ball_pos = 5;
inline bool VisionData::_internal_has_ball_pos() const {
  return this != internal_default_instance() && ball_pos_ != nullptr;
}
inline bool VisionData::has_ball_pos() const {
  return _internal_has_ball_pos();
}
inline void VisionData::clear_ball_pos() {
  if (GetArena() == nullptr && ball_pos_ != nullptr) {
    delete ball_pos_;
  }
  ball_pos_ = nullptr;
}
inline const ::Vec2D& VisionData::_internal_ball_pos() const {
  const ::Vec2D* p = ball_pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec2D*>(
      &::_Vec2D_default_instance_);
}
inline const ::Vec2D& VisionData::ball_pos() const {
  // @@protoc_insertion_point(field_get:VisionData.ball_pos)
  return _internal_ball_pos();
}
inline void VisionData::unsafe_arena_set_allocated_ball_pos(
    ::Vec2D* ball_pos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ball_pos_);
  }
  ball_pos_ = ball_pos;
  if (ball_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VisionData.ball_pos)
}
inline ::Vec2D* VisionData::release_ball_pos() {
  auto temp = unsafe_arena_release_ball_pos();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Vec2D* VisionData::unsafe_arena_release_ball_pos() {
  // @@protoc_insertion_point(field_release:VisionData.ball_pos)
  
  ::Vec2D* temp = ball_pos_;
  ball_pos_ = nullptr;
  return temp;
}
inline ::Vec2D* VisionData::_internal_mutable_ball_pos() {
  
  if (ball_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec2D>(GetArena());
    ball_pos_ = p;
  }
  return ball_pos_;
}
inline ::Vec2D* VisionData::mutable_ball_pos() {
  // @@protoc_insertion_point(field_mutable:VisionData.ball_pos)
  return _internal_mutable_ball_pos();
}
inline void VisionData::set_allocated_ball_pos(::Vec2D* ball_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ball_pos_;
  }
  if (ball_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ball_pos);
    if (message_arena != submessage_arena) {
      ball_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_pos, submessage_arena);
    }
    
  } else {
    
  }
  ball_pos_ = ball_pos;
  // @@protoc_insertion_point(field_set_allocated:VisionData.ball_pos)
}

// .Vec2D ball_vel = 6;
inline bool VisionData::_internal_has_ball_vel() const {
  return this != internal_default_instance() && ball_vel_ != nullptr;
}
inline bool VisionData::has_ball_vel() const {
  return _internal_has_ball_vel();
}
inline void VisionData::clear_ball_vel() {
  if (GetArena() == nullptr && ball_vel_ != nullptr) {
    delete ball_vel_;
  }
  ball_vel_ = nullptr;
}
inline const ::Vec2D& VisionData::_internal_ball_vel() const {
  const ::Vec2D* p = ball_vel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec2D*>(
      &::_Vec2D_default_instance_);
}
inline const ::Vec2D& VisionData::ball_vel() const {
  // @@protoc_insertion_point(field_get:VisionData.ball_vel)
  return _internal_ball_vel();
}
inline void VisionData::unsafe_arena_set_allocated_ball_vel(
    ::Vec2D* ball_vel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ball_vel_);
  }
  ball_vel_ = ball_vel;
  if (ball_vel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VisionData.ball_vel)
}
inline ::Vec2D* VisionData::release_ball_vel() {
  auto temp = unsafe_arena_release_ball_vel();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Vec2D* VisionData::unsafe_arena_release_ball_vel() {
  // @@protoc_insertion_point(field_release:VisionData.ball_vel)
  
  ::Vec2D* temp = ball_vel_;
  ball_vel_ = nullptr;
  return temp;
}
inline ::Vec2D* VisionData::_internal_mutable_ball_vel() {
  
  if (ball_vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec2D>(GetArena());
    ball_vel_ = p;
  }
  return ball_vel_;
}
inline ::Vec2D* VisionData::mutable_ball_vel() {
  // @@protoc_insertion_point(field_mutable:VisionData.ball_vel)
  return _internal_mutable_ball_vel();
}
inline void VisionData::set_allocated_ball_vel(::Vec2D* ball_vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ball_vel_;
  }
  if (ball_vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ball_vel);
    if (message_arena != submessage_arena) {
      ball_vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_vel, submessage_arena);
    }
    
  } else {
    
  }
  ball_vel_ = ball_vel;
  // @@protoc_insertion_point(field_set_allocated:VisionData.ball_vel)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_RemoteAPI_2eproto
